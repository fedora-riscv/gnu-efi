diff -urpN gnu-efi-3.0d/gnuefi/reloc_ia32.c.unify gnu-efi-3.0d/gnuefi/reloc_ia32.c
--- gnu-efi-3.0d/gnuefi/reloc_ia32.c.unify	2008-04-29 13:35:17.000000000 -0400
+++ gnu-efi-3.0d/gnuefi/reloc_ia32.c	2008-04-29 13:34:44.000000000 -0400
@@ -45,56 +45,54 @@
 #include <efi.h>
 #include <efilib.h>
 
-int
-_relocate (long ldbase, ElfW(Dyn) *dyn, EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
+EFI_STATUS _relocate (long ldbase, ElfW(Dyn) *dyn, EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
 {
-	extern EFI_STATUS efi_main (EFI_HANDLE, EFI_SYSTEM_TABLE *);
 	long relsz = 0, relent = 0;
 	ElfW(Rel) *rel = 0;
+	unsigned long *addr;
 	int i;
 
 	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
 		switch (dyn[i].d_tag) {
-		      case DT_REL:
-			rel = (ElfW(Rel)*) ((long) dyn[i].d_un.d_ptr + ldbase);
-			break;
-
-		      case DT_RELSZ:
-			relsz = dyn[i].d_un.d_val;
-			break;
-
-		      case DT_RELENT:
-			relent = dyn[i].d_un.d_val;
-			break;
+			case DT_REL:
+				rel = (ElfW(Rel)*)
+					((unsigned long)dyn[i].d_un.d_ptr
+					 + ldbase);
+				break;
+
+			case DT_RELSZ:
+				relsz = dyn[i].d_un.d_val;
+				break;
+
+			case DT_RELENT:
+				relent = dyn[i].d_un.d_val;
+				break;
 
-		      case DT_RELA:
-			break;
+			case DT_RELA:
+				break;
 
-		      default:
-			break;
+			default:
+				break;
 		}
 	}
 
-	while (relsz > 0) {
- 		if (!rel || relent == 0)
- 			return EFI_LOAD_ERROR;
+	if (!rel || relent == 0)
+		return EFI_LOAD_ERROR;
 
+	while (relsz > 0) {
 		/* apply the relocs */
 		switch (ELF32_R_TYPE (rel->r_info)) {
-		      case R_386_NONE:
-			break;
-
-		      case R_386_RELATIVE:
-		      {
-			      long *addr;
-
-			      addr = (long *) (ldbase + rel->r_offset);
-			      *addr += ldbase;
-			      break;
-		      }
+			case R_386_NONE:
+				break;
+			
+			case R_386_RELATIVE:
+				addr = (unsigned long *)
+					(ldbase + rel->r_offset);
+				*addr += ldbase;
+				break;
 
-		      default:
-			return EFI_LOAD_ERROR;
+			default:
+				break;
 		}
 		rel = (ElfW(Rel)*) ((char *) rel + relent);
 		relsz -= relent;
diff -urpN gnu-efi-3.0d/gnuefi/reloc_x86_64.c.unify gnu-efi-3.0d/gnuefi/reloc_x86_64.c
--- gnu-efi-3.0d/gnuefi/reloc_x86_64.c.unify	2008-04-29 13:35:10.000000000 -0400
+++ gnu-efi-3.0d/gnuefi/reloc_x86_64.c	2008-04-29 13:34:44.000000000 -0400
@@ -50,7 +50,6 @@
 
 EFI_STATUS _relocate (long ldbase, ElfW(Dyn) *dyn, EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
 {
-	//extern EFI_STATUS efi_main (EFI_HANDLE, EFI_SYSTEM_TABLE *);
 	long relsz = 0, relent = 0;
 	ElfW(Rel) *rel = 0;
 	unsigned long *addr;
@@ -58,43 +57,45 @@ EFI_STATUS _relocate (long ldbase, ElfW(
 
 	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
 		switch (dyn[i].d_tag) {
-		      case DT_RELA:
-			rel = (ElfW(Rel)*) ((long) dyn[i].d_un.d_ptr + ldbase);
-			break;
-
-		      case DT_RELASZ:
-			relsz = dyn[i].d_un.d_val;
-			break;
-
-		      case DT_RELAENT:
-			relent = dyn[i].d_un.d_val;
-			break;
+			case DT_RELA:
+				rel = (ElfW(Rel)*)
+					((unsigned long)dyn[i].d_un.d_ptr
+					 + ldbase);
+				break;
+
+			case DT_RELASZ:
+				relsz = dyn[i].d_un.d_val;
+				break;
+
+			case DT_RELAENT:
+				relent = dyn[i].d_un.d_val;
+				break;
 
-		      default:
-			break;
+			default:
+				break;
 		}
 	}
 
- 	if (!rel || relent == 0){
+ 	if (!rel || relent == 0)
  		return EFI_LOAD_ERROR;
-	}
+
 	while (relsz > 0) {
 		/* apply the relocs */
 		switch (ELF64_R_TYPE (rel->r_info)) {
-		      case R_X86_64_NONE:
-			break;
+			case R_X86_64_NONE:
+				break;
 
-		      case R_X86_64_RELATIVE:
-			 addr = (unsigned long *) (ldbase + rel->r_offset);
-			 *addr += ldbase;
-			      break;
+			case R_X86_64_RELATIVE:
+				addr = (unsigned long *)
+					(ldbase + rel->r_offset);
+				*addr += ldbase;
+				break;
 
-		      default:
-			break;
+			default:
+				break;
 		}
 		rel = (ElfW(Rel)*) ((char *) rel + relent);
 		relsz -= relent;
 	}
 	return EFI_SUCCESS;
 }
-
