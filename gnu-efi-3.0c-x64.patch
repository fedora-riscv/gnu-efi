diff -up gnu-efi-3.0c/Make.defaults.x64 gnu-efi-3.0c/Make.defaults
--- gnu-efi-3.0c/Make.defaults.x64	2006-03-21 05:16:25.000000000 -0500
+++ gnu-efi-3.0c/Make.defaults	2007-12-19 13:52:40.000000000 -0500
@@ -29,7 +29,7 @@ INSTALLROOT=/usr/local
 
 TOPDIR    := $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
 
-ARCH	   = $(shell uname -m | sed s,i[3456789]86,ia32,)
+ARCH	   = $(shell uname -m | sed -e s,i[3456789]86,ia32, -e s,x86_64,x64, )
 INCDIR	   = -I. -I$(CDIR)/inc -I$(CDIR)/inc/$(ARCH) -I$(CDIR)/inc/protocol 
 CPPFLAGS   = -DCONFIG_$(ARCH)
 CFLAGS	   = -O2 -fpic -Wall -fshort-wchar -fno-strict-aliasing -fno-merge-constants
@@ -46,6 +46,7 @@ ifeq ($(ARCH),ia64)
   AR		= $(prefix)ar
   RANLIB	= $(prefix)ranlib
   OBJCOPY	= $(prefix)objcopy
+  LIBDIR	= lib
 
 
 ifneq ($(GCC_VERSION),2)
@@ -54,11 +55,29 @@ endif
 
 CFLAGS += -mfixed-range=f32-f127
 
-else
- ifeq ($(ARCH),ia32)
-#
-# gcc-3.x is required
-#
+endif
+ifeq ($(ARCH),ia32)
+  #
+  # gcc-3.x is required
+  #
+  prefix	= 
+  ifneq ($(GCC_VERSION),2)
+    CC = $(prefix)gcc
+  else
+    CC = $(prefix)gcc3 #must have gcc 3.x
+  endif
+  AS		= $(prefix)as
+  LD		= $(prefix)ld
+  AR		= $(prefix)ar
+  RANLIB	= $(prefix)ranlib
+  OBJCOPY	= $(p:efix)objcopy
+  LIBDIR	= lib
+  CFLAGS        += -m32
+endif
+ifeq ($(ARCH),x64)
+  #
+  # gcc-3.x is required
+  #
   prefix	= 
   ifneq ($(GCC_VERSION),2)
     CC = $(prefix)gcc
@@ -70,6 +89,6 @@ else
   AR		= $(prefix)ar
   RANLIB	= $(prefix)ranlib
   OBJCOPY	= $(prefix)objcopy
- endif
+  LIBDIR	= lib64
+  CFLAGS       += -m64
 endif
-
diff -up gnu-efi-3.0c/apps/Makefile.x64 gnu-efi-3.0c/apps/Makefile
--- gnu-efi-3.0c/apps/Makefile.x64	2004-12-22 10:52:28.000000000 -0500
+++ gnu-efi-3.0c/apps/Makefile	2007-12-19 13:52:40.000000000 -0500
@@ -28,8 +28,8 @@ CPPFLAGS	+= -D__KERNEL__ -I$(LINUX_HEADE
 CRTOBJS		= ../gnuefi/crt0-efi-$(ARCH).o
 LDSCRIPT	= ../gnuefi/elf_$(ARCH)_efi.lds
 LDFLAGS		+= -T $(LDSCRIPT) -shared -Bsymbolic -L../lib -L../gnuefi $(CRTOBJS)
-LOADLIBES	= -lefi -lgnuefi $(shell $(CC) -print-libgcc-file-name)
-FORMAT		= efi-app-$(ARCH)
+LOADLIBES	= -lefi -lgnuefi $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+FORMAT		= efi-app-$(shell echo $(ARCH) | sed s,x64,x86_64,)
 
 TARGETS = t.efi t2.efi t3.efi t4.efi t5.efi t6.efi printenv.efi t7.efi
 
diff -up gnu-efi-3.0c/gnuefi/Makefile.x64 gnu-efi-3.0c/gnuefi/Makefile
--- gnu-efi-3.0c/gnuefi/Makefile.x64	2007-12-19 13:53:50.000000000 -0500
+++ gnu-efi-3.0c/gnuefi/Makefile	2007-12-19 13:54:01.000000000 -0500
@@ -37,8 +37,8 @@ clean:
 	rm -f $(TARGETS) *~ *.o $(OBJS)
 
 install:
-	mkdir -p $(INSTALLROOT)/lib
-	$(INSTALL) -m 644 $(TARGETS) $(INSTALLROOT)/lib
-	$(INSTALL) -m 644 elf_$(ARCH)_efi.lds $(INSTALLROOT)/lib
+	mkdir -p $(INSTALLROOT)/$(LIBDIR)
+	$(INSTALL) -m 644 $(TARGETS) $(INSTALLROOT)/$(LIBDIR)
+	$(INSTALL) -m 644 elf_$(ARCH)_efi.lds $(INSTALLROOT)/$(LIBDIR)
 
 include ../Make.rules
diff -up gnu-efi-3.0c/gnuefi/crt0-efi-x64.S.x64 gnu-efi-3.0c/gnuefi/crt0-efi-x64.S
--- gnu-efi-3.0c/gnuefi/crt0-efi-x64.S.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/gnuefi/crt0-efi-x64.S	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,63 @@
+/* crt0-efi-x86_64.S - x86_64 EFI startup code.
+   Copyright (C) 1999 Hewlett-Packard Co.
+	Contributed by David Mosberger <davidm@hpl.hp.com>.
+   Copyright (C) 2005 Intel Co.
+	Contributed by Fenghua Yu <fenghua.yu@intel.com>.
+
+   This file is part of GNU-EFI, the GNU EFI development environment.
+
+   GNU EFI is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU EFI is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU EFI; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA. */
+
+	.text
+	.align 4
+
+	.globl _start
+_start:
+	subq $8, %rsp
+	pushq %rcx
+	pushq %rdx
+
+0:
+	lea ImageBase(%rip), %rdi
+	lea _DYNAMIC(%rip), %rsi
+
+	popq %rcx
+	popq %rdx
+	pushq %rcx
+	pushq %rdx
+	call _relocate
+
+	popq %rdi
+	popq %rsi
+
+	call efi_main
+	addq $8, %rsp
+
+.exit:
+  	ret
+
+ 	// hand-craft a dummy .reloc section so EFI knows it's a relocatable executable:
+
+ 	.data
+dummy:	.long	0
+
+#define IMAGE_REL_ABSOLUTE	0
+ 	.section .reloc, "a"
+label1:
+	.long	dummy-label1				// Page RVA
+ 	.long	10					// Block Size (2*4+2)
+	.word	(IMAGE_REL_ABSOLUTE<<12) +  0		// reloc for dummy
+
diff -up gnu-efi-3.0c/gnuefi/elf_x64_efi.lds.x64 gnu-efi-3.0c/gnuefi/elf_x64_efi.lds
--- gnu-efi-3.0c/gnuefi/elf_x64_efi.lds.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/gnuefi/elf_x64_efi.lds	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,58 @@
+OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64", "elf64-x86-64")
+OUTPUT_ARCH(i386:x86-64)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0;
+  ImageBase = .;
+  .hash : { *(.hash) }	/* this MUST come first! */
+  . = ALIGN(4096);
+  .eh_frame :
+  {
+    *(.eh_frame)
+  }
+  . = ALIGN(4096);
+  .text :
+  {
+   *(.text)
+  }
+  .reloc :
+  {
+   *(.reloc)
+  }
+  . = ALIGN(4096);
+  .data :
+  {
+   *(.rodata*)
+   *(.got.plt)
+   *(.got)
+   *(.data*)
+   *(.sdata)
+   /* the EFI loader doesn't seem to like a .bss section, so we stick
+      it all into .data: */
+   *(.sbss)
+   *(.scommon)
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+   *(.rel.local)
+  }
+  . = ALIGN(4096);
+  .dynamic  : { *(.dynamic) }
+  . = ALIGN(4096);
+  .rela :
+  {
+    *(.rela.data*)
+    *(.rela.got)
+    *(.rela.stab)
+  }
+  . = ALIGN(4096);
+  .dynsym   : { *(.dynsym) }
+  . = ALIGN(4096);
+  .dynstr   : { *(.dynstr) }
+  . = ALIGN(4096);
+  .ignored.reloc :
+  {
+    *(.rela.reloc)
+  }
+}
diff -up gnu-efi-3.0c/gnuefi/reloc_x64.c.x64 gnu-efi-3.0c/gnuefi/reloc_x64.c
--- gnu-efi-3.0c/gnuefi/reloc_x64.c.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/gnuefi/reloc_x64.c	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,91 @@
+/* reloc_x64.c - position independent x86_64 ELF shared object relocator
+   Copyright (C) 1999 Hewlett-Packard Co.
+	Contributed by David Mosberger <davidm@hpl.hp.com>.
+   Copyright (C) 2005 Intel Co.
+	Contributed by Fenghua Yu <fenghua.yu@intel.com>.
+   Copyright (C) 2007 Red Hat, Inc.
+
+   This file is part of GNU-EFI, the GNU EFI development environment.
+
+   GNU EFI is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU EFI is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU EFI; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA. */
+
+#include <elf.h>
+#include <link.h>	/* get _DYNAMIC decl and ElfW and ELFW macros */
+
+#undef NULL
+#define uint64_t	efi_uint64_t
+#define int64_t		efi_int64_t
+#define uint32_t	efi_uint32_t
+#define int32_t		efi_int32_t
+#define uint16_t	efi_uint16_t
+#define int16_t		efi_int16_t
+#define uint8_t		efi_uint8_t
+#define int8_t		efi_int8_t
+
+#include <efi.h>
+#include <efilib.h>
+
+long
+_relocate(long ldbase, ElfW(Dyn) *dyn, EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
+{
+	long relsz = 0, relent = 0;
+	ElfW(Rel) *rel = 0;
+	unsigned long *addr;
+	int i;
+
+	for (i = 0; dyn[i].d_tag != DT_NULL; ++i) {
+		switch (dyn[i].d_tag) {
+		      case DT_RELA:
+			rel = (ElfW(Rel)*) ((long) dyn[i].d_un.d_ptr + ldbase);
+			break;
+
+		      case DT_RELASZ:
+			relsz = dyn[i].d_un.d_val;
+			break;
+
+		      case DT_RELAENT:
+			relent = dyn[i].d_un.d_val;
+			break;
+
+		      default:
+			break;
+		}
+	}
+
+	while (relsz > 0) {
+		if (!rel || relent == 0){
+			return EFI_LOAD_ERROR;
+		}
+
+		/* apply the relocs */
+		switch (ELF64_R_TYPE (rel->r_info)) {
+		      case R_X86_64_NONE:
+			break;
+
+		      case R_X86_64_RELATIVE:
+			 addr = (unsigned long *) (ldbase + rel->r_offset);
+			 *addr += ldbase;
+			      break;
+
+		      default:
+			return EFI_LOAD_ERROR;
+		}
+		rel = (ElfW(Rel)*) ((char *) rel + relent);
+		relsz -= relent;
+	}
+	return EFI_SUCCESS;
+}
+
diff -up gnu-efi-3.0c/inc/x64/pe.h.x64 gnu-efi-3.0c/inc/x64/pe.h
--- gnu-efi-3.0c/inc/x64/pe.h.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/inc/x64/pe.h	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,591 @@
+/* 
+    PE32+ header file
+ */
+#ifndef _PE_H
+#define _PE_H
+
+#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
+#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
+#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
+#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00  
+#define IMAGE_EDOS_SIGNATURE                0x44454550  // PEED
+
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    UINT16   e_magic;                     // Magic number
+    UINT16   e_cblp;                      // Bytes on last page of file
+    UINT16   e_cp;                        // Pages in file
+    UINT16   e_crlc;                      // Relocations
+    UINT16   e_cparhdr;                   // Size of header in paragraphs
+    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
+    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
+    UINT16   e_ss;                        // Initial (relative) SS value
+    UINT16   e_sp;                        // Initial SP value
+    UINT16   e_csum;                      // Checksum
+    UINT16   e_ip;                        // Initial IP value
+    UINT16   e_cs;                        // Initial (relative) CS value
+    UINT16   e_lfarlc;                    // File address of relocation table
+    UINT16   e_ovno;                      // Overlay number
+    UINT16   e_res[4];                    // Reserved words
+    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
+    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
+    UINT16   e_res2[10];                  // Reserved words
+    UINT32   e_lfanew;                    // File address of new exe header
+  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header
+    UINT16   ne_magic;                    // Magic number
+    UINT8    ne_ver;                      // Version number
+    UINT8    ne_rev;                      // Revision number
+    UINT16   ne_enttab;                   // Offset of Entry Table
+    UINT16   ne_cbenttab;                 // Number of bytes in Entry Table
+    UINT32   ne_crc;                      // Checksum of whole file
+    UINT16   ne_flags;                    // Flag UINT16
+    UINT16   ne_autodata;                 // Automatic data segment number
+    UINT16   ne_heap;                     // Initial heap allocation
+    UINT16   ne_stack;                    // Initial stack allocation
+    UINT32   ne_csip;                     // Initial CS:IP setting
+    UINT32   ne_sssp;                     // Initial SS:SP setting
+    UINT16   ne_cseg;                     // Count of file segments
+    UINT16   ne_cmod;                     // Entries in Module Reference Table
+    UINT16   ne_cbnrestab;                // Size of non-resident name table
+    UINT16   ne_segtab;                   // Offset of Segment Table
+    UINT16   ne_rsrctab;                  // Offset of Resource Table
+    UINT16   ne_restab;                   // Offset of resident name table
+    UINT16   ne_modtab;                   // Offset of Module Reference Table
+    UINT16   ne_imptab;                   // Offset of Imported Names Table
+    UINT32   ne_nrestab;                  // Offset of Non-resident Names Table
+    UINT16   ne_cmovent;                  // Count of movable entries
+    UINT16   ne_align;                    // Segment alignment shift count
+    UINT16   ne_cres;                     // Count of resource segments
+    UINT8    ne_exetyp;                   // Target Operating system
+    UINT8    ne_flagsothers;              // Other .EXE flags
+    UINT16   ne_pretthunks;               // offset to return thunks
+    UINT16   ne_psegrefbytes;             // offset to segment ref. bytes
+    UINT16   ne_swaparea;                 // Minimum code swap area size
+    UINT16   ne_expver;                   // Expected Windows version number
+  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
+
+//
+// File header format.
+//
+
+typedef struct _IMAGE_FILE_HEADER {
+    UINT16   Machine;
+    UINT16   NumberOfSections;
+    UINT32   TimeDateStamp;
+    UINT32   PointerToSymbolTable;
+    UINT32   NumberOfSymbols;
+    UINT16   SizeOfOptionalHeader;
+    UINT16   Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+#define IMAGE_SIZEOF_FILE_HEADER             20
+
+#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
+#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
+#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
+#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
+#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
+#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
+#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
+#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
+#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
+#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.
+
+#define IMAGE_FILE_MACHINE_UNKNOWN           0
+#define IMAGE_FILE_MACHINE_I386              0x14c   // Intel 386.
+#define IMAGE_FILE_MACHINE_R3000             0x162   // MIPS little-endian, 0540 big-endian
+#define IMAGE_FILE_MACHINE_R4000             0x166   // MIPS little-endian
+#define IMAGE_FILE_MACHINE_ALPHA             0x184   // Alpha_AXP
+#define IMAGE_FILE_MACHINE_POWERPC           0x1F0   // IBM PowerPC Little-Endian
+#define IMAGE_FILE_MACHINE_TAHOE             0x7cc   // Intel EM machine
+//
+// Directory format.
+//
+
+typedef struct _IMAGE_DATA_DIRECTORY {
+    UINT64   VirtualAddress;
+    UINT32   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+//
+// Optional header format.
+//
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    UINT16    Magic;
+    UINT8     MajorLinkerVersion;
+    UINT8     MinorLinkerVersion;
+    UINT32    SizeOfCode;
+    UINT32    SizeOfInitializedData;
+    UINT32    SizeOfUninitializedData;
+    UINT64    AddressOfEntryPoint;
+    UINT64    BaseOfCode;
+    UINT64    BaseOfData;
+                
+    //
+    // NT additional fields.
+    //
+
+    UINT64   ImageBase;
+    UINT32   SectionAlignment;
+    UINT32   FileAlignment;
+    UINT16   MajorOperatingSystemVersion;
+    UINT16   MinorOperatingSystemVersion;
+    UINT16   MajorImageVersion;
+    UINT16   MinorImageVersion;
+    UINT16   MajorSubsystemVersion;
+    UINT16   MinorSubsystemVersion;
+    UINT32   Reserved1;
+    UINT32   SizeOfImage;
+    UINT32   SizeOfHeaders;
+    UINT32   CheckSum;
+    UINT16   Subsystem;
+    UINT16   DllCharacteristics;
+    UINT32   SizeOfStackReserve;
+    UINT32   SizeOfStackCommit;
+    UINT32   SizeOfHeapReserve;
+    UINT32   SizeOfHeapCommit;
+    UINT32   LoaderFlags;
+    UINT32   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
+
+typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
+    UINT16  Magic;
+    UINT8   MajorLinkerVersion;
+    UINT8   MinorLinkerVersion;
+    UINT32  SizeOfCode;
+    UINT32  SizeOfInitializedData;
+    UINT32  SizeOfUninitializedData;
+    UINT32  AddressOfEntryPoint;
+    UINT32  BaseOfCode;
+    UINT32  BaseOfData;
+    UINT32  BaseOfBss;
+    UINT32  GprMask;
+    UINT32  CprMask[4];
+    UINT32  GpValue;
+} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
+
+#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56
+#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28
+#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER      224
+
+#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b
+#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107
+
+typedef struct _IMAGE_NT_HEADERS {
+    UINT32 Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
+
+typedef struct _IMAGE_ROM_HEADERS {
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
+} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
+
+#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
+    ((UINT32)ntheader +                                                  \
+     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
+     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
+    ))
+
+
+// Subsystem Values
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
+#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
+#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
+#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image run  in the Posix character subsystem.
+
+
+// Directory Entries
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT         0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT         1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY       4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG          6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7   // Description String
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8   // Machine Value (MIPS GP)
+#define IMAGE_DIRECTORY_ENTRY_TLS            9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10   // Load Configuration Directory
+
+//
+// Section header format.
+//
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    UINT8   Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+            UINT32   PhysicalAddress;
+            UINT32   VirtualSize;
+    } Misc;
+    UINT32   VirtualAddress;
+    UINT32   SizeOfRawData;
+    UINT32   PointerToRawData;
+    UINT32   PointerToRelocations;
+    UINT32   PointerToLinenumbers;
+    UINT16   NumberOfRelocations;
+    UINT16   NumberOfLinenumbers;
+    UINT32   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+
+#define IMAGE_SIZEOF_SECTION_HEADER          40
+
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+//
+// Symbol format.
+//
+
+
+#define IMAGE_SIZEOF_SYMBOL                  18
+
+//
+// Section values.
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+
+#define IMAGE_SYM_UNDEFINED           (UINT16)0           // Symbol is undefined or is common.
+#define IMAGE_SYM_ABSOLUTE            (UINT16)-1          // Symbol is an absolute value.
+#define IMAGE_SYM_DEBUG               (UINT16)-2          // Symbol is a special debug item.
+
+//
+// Type (fundamental) values.
+//
+
+#define IMAGE_SYM_TYPE_NULL                  0           // no type.
+#define IMAGE_SYM_TYPE_VOID                  1           //
+#define IMAGE_SYM_TYPE_CHAR                  2           // type character.
+#define IMAGE_SYM_TYPE_SHORT                 3           // type short integer.
+#define IMAGE_SYM_TYPE_INT                   4           //
+#define IMAGE_SYM_TYPE_LONG                  5           //
+#define IMAGE_SYM_TYPE_FLOAT                 6           //
+#define IMAGE_SYM_TYPE_DOUBLE                7           //
+#define IMAGE_SYM_TYPE_STRUCT                8           //
+#define IMAGE_SYM_TYPE_UNION                 9           //
+#define IMAGE_SYM_TYPE_ENUM                  10          // enumeration.
+#define IMAGE_SYM_TYPE_MOE                   11          // member of enumeration.
+#define IMAGE_SYM_TYPE_BYTE                  12          //
+#define IMAGE_SYM_TYPE_WORD                  13          //
+#define IMAGE_SYM_TYPE_UINT                  14          //
+#define IMAGE_SYM_TYPE_DWORD                 15          //
+
+//
+// Type (derived) values.
+//
+
+#define IMAGE_SYM_DTYPE_NULL                 0           // no derived type.
+#define IMAGE_SYM_DTYPE_POINTER              1           // pointer.
+#define IMAGE_SYM_DTYPE_FUNCTION             2           // function.
+#define IMAGE_SYM_DTYPE_ARRAY                3           // array.
+
+//
+// Storage classes.
+//
+
+#define IMAGE_SYM_CLASS_END_OF_FUNCTION      (BYTE )-1
+#define IMAGE_SYM_CLASS_NULL                 0
+#define IMAGE_SYM_CLASS_AUTOMATIC            1
+#define IMAGE_SYM_CLASS_EXTERNAL             2
+#define IMAGE_SYM_CLASS_STATIC               3
+#define IMAGE_SYM_CLASS_REGISTER             4
+#define IMAGE_SYM_CLASS_EXTERNAL_DEF         5
+#define IMAGE_SYM_CLASS_LABEL                6
+#define IMAGE_SYM_CLASS_UNDEFINED_LABEL      7
+#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT     8
+#define IMAGE_SYM_CLASS_ARGUMENT             9
+#define IMAGE_SYM_CLASS_STRUCT_TAG           10
+#define IMAGE_SYM_CLASS_MEMBER_OF_UNION      11
+#define IMAGE_SYM_CLASS_UNION_TAG            12
+#define IMAGE_SYM_CLASS_TYPE_DEFINITION      13
+#define IMAGE_SYM_CLASS_UNDEFINED_STATIC     14
+#define IMAGE_SYM_CLASS_ENUM_TAG             15
+#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM       16
+#define IMAGE_SYM_CLASS_REGISTER_PARAM       17
+#define IMAGE_SYM_CLASS_BIT_FIELD            18
+#define IMAGE_SYM_CLASS_BLOCK                100
+#define IMAGE_SYM_CLASS_FUNCTION             101
+#define IMAGE_SYM_CLASS_END_OF_STRUCT        102
+#define IMAGE_SYM_CLASS_FILE                 103
+// new
+#define IMAGE_SYM_CLASS_SECTION              104
+#define IMAGE_SYM_CLASS_WEAK_EXTERNAL        105
+
+// type packing constants
+
+#define N_BTMASK                            017
+#define N_TMASK                             060
+#define N_TMASK1                            0300
+#define N_TMASK2                            0360
+#define N_BTSHFT                            4
+#define N_TSHIFT                            2
+
+// MACROS
+
+//
+// Communal selection types.
+//
+
+#define IMAGE_COMDAT_SELECT_NODUPLICATES   1
+#define IMAGE_COMDAT_SELECT_ANY            2
+#define IMAGE_COMDAT_SELECT_SAME_SIZE      3
+#define IMAGE_COMDAT_SELECT_EXACT_MATCH    4
+#define IMAGE_COMDAT_SELECT_ASSOCIATIVE    5
+
+#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
+#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY   2
+#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS     3
+
+
+//
+// Relocation format.
+//
+
+typedef struct _IMAGE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SymbolTableIndex;
+    UINT16    Type;
+} IMAGE_RELOCATION;
+
+#define IMAGE_SIZEOF_RELOCATION              10
+
+//
+// I386 relocation types.
+//
+
+#define IMAGE_REL_I386_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_I386_DIR16                 01          // Direct 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_REL16                 02          // PC-relative 16-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32                 06          // Direct 32-bit reference to the symbols virtual address
+#define IMAGE_REL_I386_DIR32NB               07          // Direct 32-bit reference to the symbols virtual address, base not included
+#define IMAGE_REL_I386_SEG12                 011         // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
+#define IMAGE_REL_I386_SECTION               012
+#define IMAGE_REL_I386_SECREL                013
+#define IMAGE_REL_I386_REL32                 024         // PC-relative 32-bit reference to the symbols virtual address
+
+//
+// MIPS relocation types.
+//
+
+#define IMAGE_REL_MIPS_ABSOLUTE              0           // Reference is absolute, no relocation is necessary
+#define IMAGE_REL_MIPS_REFHALF               01
+#define IMAGE_REL_MIPS_REFWORD               02
+#define IMAGE_REL_MIPS_JMPADDR               03
+#define IMAGE_REL_MIPS_REFHI                 04
+#define IMAGE_REL_MIPS_REFLO                 05
+#define IMAGE_REL_MIPS_GPREL                 06
+#define IMAGE_REL_MIPS_LITERAL               07
+#define IMAGE_REL_MIPS_SECTION               012
+#define IMAGE_REL_MIPS_SECREL                013
+#define IMAGE_REL_MIPS_REFWORDNB             042
+#define IMAGE_REL_MIPS_PAIR                  045
+
+//
+// Alpha Relocation types.
+//
+
+#define IMAGE_REL_ALPHA_ABSOLUTE             0x0
+#define IMAGE_REL_ALPHA_REFLONG              0x1
+#define IMAGE_REL_ALPHA_REFQUAD              0x2
+#define IMAGE_REL_ALPHA_GPREL32              0x3
+#define IMAGE_REL_ALPHA_LITERAL              0x4
+#define IMAGE_REL_ALPHA_LITUSE               0x5
+#define IMAGE_REL_ALPHA_GPDISP               0x6
+#define IMAGE_REL_ALPHA_BRADDR               0x7
+#define IMAGE_REL_ALPHA_HINT                 0x8
+#define IMAGE_REL_ALPHA_INLINE_REFLONG       0x9
+#define IMAGE_REL_ALPHA_REFHI                0xA
+#define IMAGE_REL_ALPHA_REFLO                0xB
+#define IMAGE_REL_ALPHA_PAIR                 0xC
+#define IMAGE_REL_ALPHA_MATCH                0xD
+#define IMAGE_REL_ALPHA_SECTION              0xE
+#define IMAGE_REL_ALPHA_SECREL               0xF
+#define IMAGE_REL_ALPHA_REFLONGNB            0x10
+
+//
+// IBM PowerPC relocation types.
+//
+
+#define IMAGE_REL_PPC_ABSOLUTE 0x0000  // NOP
+#define IMAGE_REL_PPC_ADDR64   0x0001  // 64-bit address
+#define IMAGE_REL_PPC_ADDR32   0x0002  // 32-bit address
+#define IMAGE_REL_PPC_ADDR24   0x0003  // 26-bit address, shifted left 2 (branch absolute)
+#define IMAGE_REL_PPC_ADDR16   0x0004  // 16-bit address
+#define IMAGE_REL_PPC_ADDR14   0x0005  // 16-bit address, shifted left 2 (load doubleword)
+#define IMAGE_REL_PPC_REL24    0x0006  // 26-bit PC-relative offset, shifted left 2 (branch relative)
+#define IMAGE_REL_PPC_REL14    0x0007  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
+#define IMAGE_REL_PPC_TOCREL16 0x0008  // 16-bit offset from TOC base
+#define IMAGE_REL_PPC_TOCREL14 0x0009  // 16-bit offset from TOC base, shifted left 2 (load doubleword)
+
+#define IMAGE_REL_PPC_ADDR32NB 0x000A  // 32-bit addr w/o image base
+#define IMAGE_REL_PPC_SECREL   0x000B  // va of containing section (as in an image sectionhdr)
+#define IMAGE_REL_PPC_SECTION  0x000C  // sectionheader number
+#define IMAGE_REL_PPC_IFGLUE   0x000D  // substitute TOC restore instruction iff symbol is glue code
+#define IMAGE_REL_PPC_IMGLUE   0x000E  // symbol is glue code; virtual address is TOC restore instruction
+
+#define IMAGE_REL_PPC_TYPEMASK 0x00FF  // mask to isolate above values in IMAGE_RELOCATION.Type
+
+// Flag bits in IMAGE_RELOCATION.TYPE
+
+#define IMAGE_REL_PPC_NEG      0x0100  // subtract reloc value rather than adding it
+#define IMAGE_REL_PPC_BRTAKEN  0x0200  // fix branch prediction bit to predict branch taken
+#define IMAGE_REL_PPC_BRNTAKEN 0x0400  // fix branch prediction bit to predict branch not taken
+#define IMAGE_REL_PPC_TOCDEFN  0x0800  // toc slot defined in file (or, data in toc)
+
+//
+// Based relocation format.
+//
+
+typedef struct _IMAGE_BASE_RELOCATION {
+    UINT32   VirtualAddress;
+    UINT32   SizeOfBlock;
+//  UINT16    TypeOffset[1];
+} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
+
+#define IMAGE_SIZEOF_BASE_RELOCATION         8
+
+//
+// Based relocation types.
+//
+
+#define IMAGE_REL_BASED_ABSOLUTE              0
+#define IMAGE_REL_BASED_HIGH                  1
+#define IMAGE_REL_BASED_LOW                   2
+#define IMAGE_REL_BASED_HIGHLOW               3
+#define IMAGE_REL_BASED_HIGHADJ               4
+#define IMAGE_REL_BASED_MIPS_JMPADDR          5
+#define IMAGE_REL_BASED_IA64_IMM64            9
+#define IMAGE_REL_BASED_DIR64                 10
+
+//
+// Line number format.
+//
+
+typedef struct _IMAGE_LINENUMBER {
+    union {
+        UINT32   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
+        UINT32   VirtualAddress;                 // Virtual address of line number.
+    } Type;
+    UINT16    Linenumber;                         // Line number.
+} IMAGE_LINENUMBER;
+
+#define IMAGE_SIZEOF_LINENUMBER              6
+
+//
+// Archive format.
+//
+
+#define IMAGE_ARCHIVE_START_SIZE             8
+#define IMAGE_ARCHIVE_START                  "!<arch>\n"
+#define IMAGE_ARCHIVE_END                    "`\n"
+#define IMAGE_ARCHIVE_PAD                    "\n"
+#define IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
+#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
+
+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
+    UINT8     Name[16];                          // File member name - `/' terminated.
+    UINT8     Date[12];                          // File member date - decimal.
+    UINT8     UserID[6];                         // File member user id - decimal.
+    UINT8     GroupID[6];                        // File member group id - decimal.
+    UINT8     Mode[8];                           // File member mode - octal.
+    UINT8     Size[10];                          // File member size - decimal.
+    UINT8     EndHeader[2];                      // String to end header.
+} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
+
+#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60
+
+//
+// DLL support.
+//
+
+//
+// Export Format
+//
+
+typedef struct _IMAGE_EXPORT_DIRECTORY {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT16   MajorVersion;
+    UINT16   MinorVersion;
+    UINT32   Name;
+    UINT32   Base;
+    UINT32   NumberOfFunctions;
+    UINT32   NumberOfNames;
+    UINT32   *AddressOfFunctions;
+    UINT32   *AddressOfNames;
+    UINT32   *AddressOfNameOrdinals;
+} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
+
+//
+// Import Format
+//
+
+typedef struct _IMAGE_IMPORT_BY_NAME {
+    UINT16    Hint;
+    UINT8     Name[1];
+} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
+
+typedef struct _IMAGE_THUNK_DATA {
+    union {
+        UINT32 Function;
+        UINT32 Ordinal;
+        PIMAGE_IMPORT_BY_NAME AddressOfData;
+    } u1;
+} IMAGE_THUNK_DATA, *PIMAGE_THUNK_DATA;
+
+#define IMAGE_ORDINAL_FLAG 0x80000000
+#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
+#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
+
+typedef struct _IMAGE_IMPORT_DESCRIPTOR {
+    UINT32   Characteristics;
+    UINT32   TimeDateStamp;
+    UINT32   ForwarderChain;
+    UINT32   Name;
+    PIMAGE_THUNK_DATA FirstThunk;
+} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
+
+#endif
diff -up gnu-efi-3.0c/inc/x64/efilibplat.h.x64 gnu-efi-3.0c/inc/x64/efilibplat.h
--- gnu-efi-3.0c/inc/x64/efilibplat.h.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/inc/x64/efilibplat.h	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,26 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efilibplat.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    );
+
+   
diff -up gnu-efi-3.0c/inc/x64/efibind.h.x64 gnu-efi-3.0c/inc/x64/efibind.h
--- gnu-efi-3.0c/inc/x64/efibind.h.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/inc/x64/efibind.h	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,263 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    efefind.h
+
+Abstract:
+
+    EFI to compile bindings
+
+
+
+
+Revision History
+
+--*/
+
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+//
+// Basic int types of various widths
+//
+
+#if (__STDC_VERSION__ < 199901L )
+
+    // No ANSI C 1999/2000 stdint.h integer width declarations 
+
+    #if _MSC_EXTENSIONS
+
+        // Use Microsoft C compiler integer width declarations 
+
+        typedef unsigned __int64    uint64_t;
+        typedef __int64             int64_t;
+        typedef unsigned __int32    uint32_t;
+        typedef __int32             int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(__GNUC__)
+        typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+        typedef long long           int64_t __attribute__((aligned (8)));
+        typedef unsigned int        uint32_t;
+        typedef int                 int32_t;
+        typedef unsigned short      uint16_t;
+        typedef short               int16_t;
+        typedef unsigned char       uint8_t;
+        typedef char                int8_t;
+    #elif defined(UNIX_LP64)
+
+        /*  Use LP64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long       uint64_t;
+       typedef long                int64_t;
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #else
+
+       /*  Assume P64 programming model from C_FLAGS for integer width declarations */
+
+       typedef unsigned long long  uint64_t __attribute__((aligned (8)));
+       typedef long long           int64_t __attribute__((aligned (8)));
+       typedef unsigned int        uint32_t;
+       typedef int                 int32_t;
+       typedef unsigned short      uint16_t;
+       typedef short               int16_t;
+       typedef unsigned char       uint8_t;
+       typedef char                int8_t;
+    #endif
+#endif
+
+//
+// Basic EFI types of various widths
+//
+
+#ifndef __WCHAR_TYPE__
+# define __WCHAR_TYPE__ short
+#endif
+
+typedef uint64_t   UINT64;
+typedef int64_t    INT64;
+
+#ifndef _BASETSD_H_
+    typedef uint32_t   UINT32;
+    typedef int32_t    INT32;
+#endif
+
+typedef uint16_t   UINT16;
+typedef int16_t    INT16;
+typedef uint8_t    UINT8;
+typedef int8_t     INT8;
+typedef __WCHAR_TYPE__ WCHAR;
+
+#undef VOID
+#define VOID    void
+
+
+typedef int64_t    INTN;
+typedef uint64_t   UINTN;
+
+#ifdef EFI_NT_EMULATOR
+    #define POST_CODE(_Data)
+#else    
+    #ifdef EFI_DEBUG
+#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
+    #else
+        #define POST_CODE(_Data)
+    #endif  
+#endif
+
+#define EFIERR(a)           (0x8000000000000000UL | a)
+#define EFI_ERROR_MASK      0x8000000000000000UL
+#define EFIERR_OEM(a)       (0xc000000000000000UL | a)      
+
+
+#define BAD_POINTER         0xFBFBFBFBFBFBFBFBUL
+#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFFUL
+
+#ifdef EFI_NT_EMULATOR
+    #define BREAKPOINT()        __asm { int 3 }
+#else
+    #define BREAKPOINT()        while (TRUE);    // Make it hang on Bios[Dbg]32
+#endif
+
+//
+// Pointers must be aligned to these address to function
+//
+
+#define MIN_ALIGNMENT_SIZE  8
+
+#define ALIGN_VARIABLE(Value ,Adjustment) \
+            (UINTN)Adjustment = 0; \
+            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
+                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
+            Value = (UINTN)Value + (UINTN)Adjustment
+
+
+//
+// Define macros to build data structure signatures from characters.
+//
+
+#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
+#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
+#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | ((UINT64)(EFI_SIGNATURE_32(E,F,G,H)) << 32))
+//
+// To export & import functions in the EFI emulator environment
+//
+
+#if EFI_NT_EMULATOR
+    #define EXPORTAPI           __declspec( dllexport )
+#else
+    #define EXPORTAPI
+#endif
+
+
+//
+// EFIAPI - prototype calling convention for EFI function pointers
+// BOOTSERVICE - prototype for implementation of a boot service interface
+// RUNTIMESERVICE - prototype for implementation of a runtime service interface
+// RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
+// RUNTIME_CODE - pragma macro for declaring runtime code    
+//
+
+#ifndef EFIAPI                  // Forces EFI calling conventions reguardless of compiler options 
+    #if _MSC_EXTENSIONS
+        #define EFIAPI __cdecl  // Force C calling convention for Microsoft C compiler 
+    #else
+        #define EFIAPI          // Substitute expresion to force C calling convention 
+    #endif
+#endif
+
+#define BOOTSERVICE
+//#define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
+//#define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a
+#define RUNTIMESERVICE
+#define RUNTIMEFUNCTION
+
+
+#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
+#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
+#define END_RUNTIME_DATA()      data_seg("")
+
+#define VOLATILE    volatile
+
+#define MEMORY_FENCE()    
+
+#ifdef EFI_NT_EMULATOR
+
+//
+// To help ensure proper coding of integrated drivers, they are
+// compiled as DLLs.  In NT they require a dll init entry pointer.
+// The macro puts a stub entry point into the DLL so it will load.
+//
+
+#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
+    UINTN                                       \
+    __stdcall                                   \
+    _DllMainCRTStartup (                        \
+        UINTN    Inst,                          \
+        UINTN    reason_for_call,               \
+        VOID    *rserved                        \
+        )                                       \
+    {                                           \
+        return 1;                               \
+    }                                           \
+                                                \
+    int                                         \
+    EXPORTAPI                                   \
+    __cdecl                                     \
+    InitializeDriver (                          \
+        void *ImageHandle,                      \
+        void *SystemTable                       \
+        )                                       \
+    {                                           \
+        return InitFunction(ImageHandle, SystemTable);       \
+    }
+
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
+        (_if)->LoadInternal(type, name, NULL)             
+
+#else // EFI_NT_EMULATOR 
+
+//
+// When build similiar to FW, then link everything together as
+// one big module.
+//
+
+    #define EFI_DRIVER_ENTRY_POINT(InitFunction)
+
+    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
+            (_if)->LoadInternal(type, name, entry)
+
+#endif // EFI_FW_NT 
+
+//
+// Some compilers don't support the forward reference construct:
+//  typedef struct XXXXX
+//
+// The following macro provide a workaround for such cases.
+//
+#ifdef NO_INTERFACE_DECL
+#define INTERFACE_DECL(x)
+#else
+#ifdef __GNUC__
+#define INTERFACE_DECL(x) struct x
+#else
+#define INTERFACE_DECL(x) typedef struct x
+#endif
+#endif
+
+#if _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  // Suppress warnings about modification of EBP
+#endif
+
diff -up gnu-efi-3.0c/lib/Makefile.x64 gnu-efi-3.0c/lib/Makefile
--- gnu-efi-3.0c/lib/Makefile.x64	2004-12-22 10:52:29.000000000 -0500
+++ gnu-efi-3.0c/lib/Makefile	2007-12-19 13:52:40.000000000 -0500
@@ -41,7 +41,7 @@ clean:
 	rm -f libefi.a *~ $(OBJS) */*.o
 
 install: libefi.a
-	mkdir -p $(INSTALLROOT)/lib
-	$(INSTALL) -m 644 libefi.a $(INSTALLROOT)/lib/
+	mkdir -p $(INSTALLROOT)/$(LIBDIR)
+	$(INSTALL) -m 644 libefi.a $(INSTALLROOT)/$(LIBDIR)
 
 include ../Make.rules
diff -up gnu-efi-3.0c/lib/smbios.c.x64 gnu-efi-3.0c/lib/smbios.c
--- gnu-efi-3.0c/lib/smbios.c.x64	2004-12-22 10:52:29.000000000 -0500
+++ gnu-efi-3.0c/lib/smbios.c	2007-12-19 13:52:40.000000000 -0500
@@ -34,8 +34,8 @@ LibGetSmbiosSystemGuidAndSerialNumber (
         return EFI_NOT_FOUND;
     }
 
-    Smbios.Hdr = (SMBIOS_HEADER *)SmbiosTable->TableAddress;
-    SmbiosEnd.Raw = (UINT8 *)(SmbiosTable->TableAddress + SmbiosTable->TableLength);
+    Smbios.Hdr = (SMBIOS_HEADER *)(unsigned long)SmbiosTable->TableAddress;
+    SmbiosEnd.Raw = (UINT8 *)(unsigned long)(SmbiosTable->TableAddress + SmbiosTable->TableLength);
     for (Index = 0; Index < SmbiosTable->TableLength ; Index++) {
         if (Smbios.Hdr->Type == 1) {
             if (Smbios.Hdr->Length < 0x19) {
diff -up gnu-efi-3.0c/lib/x64/initplat.c.x64 gnu-efi-3.0c/lib/x64/initplat.c
--- gnu-efi-3.0c/lib/x64/initplat.c.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/lib/x64/initplat.c	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,28 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    initplat.c
+
+Abstract:
+
+
+
+
+Revision History
+
+--*/
+
+#include "lib.h"
+
+VOID
+InitializeLibPlatform (
+    IN EFI_HANDLE           ImageHandle,
+    IN EFI_SYSTEM_TABLE     *SystemTable
+    )
+
+{
+}
+
diff -up gnu-efi-3.0c/lib/x64/math.c.x64 gnu-efi-3.0c/lib/x64/math.c
--- gnu-efi-3.0c/lib/x64/math.c.x64	2007-12-19 13:52:40.000000000 -0500
+++ gnu-efi-3.0c/lib/x64/math.c	2007-12-19 13:52:40.000000000 -0500
@@ -0,0 +1,181 @@
+/*++
+
+Copyright (c) 1998  Intel Corporation
+
+Module Name:
+
+    math.c
+
+Abstract:
+
+
+
+
+Revision History
+
+--*/
+
+#include "lib.h"
+
+
+//
+// Declare runtime functions
+//
+
+#ifdef RUNTIME_CODE
+#ifndef __GNUC__
+#pragma RUNTIME_CODE(LShiftU64)
+#pragma RUNTIME_CODE(RShiftU64)
+#pragma RUNTIME_CODE(MultU64x32)
+#pragma RUNTIME_CODE(DivU64x32)
+#endif
+#endif
+
+//
+//
+//
+
+UINT64
+LShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    )
+// Left shift 64bit by 32bit and get a 64bit result
+{
+#ifdef __GNUC__
+    return Operand << Count;
+#else
+    UINT64      Result;
+    _asm {
+        mov     eax, dword ptr Operand[0]
+        mov     edx, dword ptr Operand[4]
+        mov     ecx, Count
+        and     ecx, 63
+
+        shld    edx, eax, cl
+        shl     eax, cl
+
+        cmp     ecx, 32
+        jc      short ls10
+
+        mov     edx, eax
+        xor     eax, eax
+
+ls10:
+        mov     dword ptr Result[0], eax
+        mov     dword ptr Result[4], edx
+    }
+
+    return Result;
+#endif
+}
+
+UINT64
+RShiftU64 (
+    IN UINT64   Operand,
+    IN UINTN    Count
+    )
+// Right shift 64bit by 32bit and get a 64bit result
+{
+#ifdef __GNUC__
+    return Operand >> Count;
+#else
+    UINT64      Result;
+    _asm {
+        mov     eax, dword ptr Operand[0]
+        mov     edx, dword ptr Operand[4]
+        mov     ecx, Count
+        and     ecx, 63
+
+        shrd    eax, edx, cl
+        shr     edx, cl
+
+        cmp     ecx, 32
+        jc      short rs10
+
+        mov     eax, edx
+        xor     edx, edx
+
+rs10:
+        mov     dword ptr Result[0], eax
+        mov     dword ptr Result[4], edx
+    }
+
+    return Result;
+#endif
+}
+
+
+UINT64
+MultU64x32 (
+    IN UINT64   Multiplicand,
+    IN UINTN    Multiplier
+    )
+// Multiple 64bit by 32bit and get a 64bit result
+{
+#ifdef __GNUC__
+    return Multiplicand * Multiplier;
+#else
+    UINT64      Result;
+    _asm {
+        mov     eax, dword ptr Multiplicand[0]
+        mul     Multiplier
+        mov     dword ptr Result[0], eax
+        mov     dword ptr Result[4], edx
+        mov     eax, dword ptr Multiplicand[4]
+        mul     Multiplier
+        add     dword ptr Result[4], eax
+    }
+
+    return Result;
+#endif
+}
+
+UINT64
+DivU64x32 (
+    IN UINT64   Dividend,
+    IN UINTN    Divisor,
+    OUT UINTN   *Remainder OPTIONAL
+    )
+// divide 64bit by 32bit and get a 64bit result
+// N.B. only works for 31bit divisors!!
+{
+#ifdef __GNUC__
+    if (Remainder)
+	*Remainder = Dividend % Divisor;
+    return Dividend / Divisor;
+#else
+    UINT32      Rem;
+    UINT32      bit;        
+
+    ASSERT (Divisor != 0);
+    ASSERT ((Divisor >> 31) == 0);
+
+    //
+    // For each bit in the dividend
+    //
+
+    Rem = 0;
+    for (bit=0; bit < 64; bit++) {
+        _asm {
+            shl     dword ptr Dividend[0], 1    ; shift rem:dividend left one
+            rcl     dword ptr Dividend[4], 1    
+            rcl     dword ptr Rem, 1            
+
+            mov     eax, Rem
+            cmp     eax, Divisor                ; Is Rem >= Divisor?
+            cmc                                 ; No - do nothing
+            sbb     eax, eax                    ; Else, 
+            sub     dword ptr Dividend[0], eax  ;   set low bit in dividen
+            and     eax, Divisor                ; and
+            sub     Rem, eax                    ;   subtract divisor 
+        }
+    }
+
+    if (Remainder) {
+        *Remainder = Rem;
+    }
+
+    return Dividend;
+#endif
+}
